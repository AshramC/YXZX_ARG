<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Campus Puzzle System</title>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <style>
        body {
            margin: 0; padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Impact', sans-serif;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            height: 100vh; color: #f2f2f2;
        }

        #game-box {
            background-color: #333;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.5s;
        }

        #ui-layer {
            position: absolute;
            top: 50px; left: 0; width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        .level-indicator {
            font-size: 24px; letter-spacing: 2px;
            color: #d90018; /* P5 Red */
            text-shadow: 2px 2px 0 #000;
            background: rgba(0,0,0,0.6);
            padding: 5px 20px;
            display: inline-block;
            transform: skew(-10deg);
            border: 2px solid #fff;
        }

        #loading-layer {
            position: absolute;
            font-size: 32px; letter-spacing: 2px;
            color: #d90018;
            text-transform: uppercase;
            text-shadow: 3px 3px 0 #000;
        }

        /* === P5 风格操作指引 === */
        .controls-hud {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            z-index: 20;
            pointer-events: none;
            font-family: 'Impact', 'SimHei', 'Heiti SC', sans-serif;
        }

        .control-item {
            background: black;
            color: white;
            padding: 8px 20px;
            font-size: 20px;
            letter-spacing: 2px;
            border: 2px solid white;
            transform: skew(-15deg);
            box-shadow: 4px 4px 0 rgba(217, 0, 24, 0.8);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-key {
            color: #d90018;
            font-weight: 900;
            border-bottom: 2px solid #d90018;
            padding-bottom: 2px;
        }

        /* 入场动画 */
        .controls-hud {
            animation: slideIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            opacity: 0;
            transform: translateY(20px);
        }

        @keyframes slideIn {
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="level-badge" class="level-indicator">LEVEL 1 / 3</div>
</div>

<div class="controls-hud">
    <div class="control-item">
        <span class="control-key">按住左键</span>
        <span>拖拽移动</span>
    </div>
    <div class="control-item">
        <span class="control-key">双击 / 右键</span>
        <span>旋转碎片</span>
    </div>
</div>

<div id="loading-layer">初始化中...</div>
<div id="game-box"></div>

<script>
    // === 全局配置 ===
    let CONFIG = {
        rows: 3,
        cols: 3,
        snapDist: 25,
        jitterAmount: 45,
        levelImages: ['pic1.jpg'],
        basePath: ''
    };

    // === 游戏状态 ===
    let gameState = {
        currentLevelIndex: 0,
        isGameActive: false,
        completedCount: 0
    };

    let stage, layer;

    // ==========================================
    // 1. 通信模块
    // ==========================================
    window.addEventListener('message', (event) => {
        const data = event.data;
        if (data && data.type === 'init') {
            console.log('[Puzzle] Init data received:', data);

            const incomingConfig = data.node?.config || {};

            if (incomingConfig.images && Array.isArray(incomingConfig.images)) {
                CONFIG.levelImages = incomingConfig.images;
            }
            if (incomingConfig.basePath) {
                CONFIG.basePath = incomingConfig.basePath;
            }
            if (incomingConfig.rows) CONFIG.rows = incomingConfig.rows;
            if (incomingConfig.cols) CONFIG.cols = incomingConfig.cols;

            gameState.currentLevelIndex = 0;
            startLevel();
        }
    });

    // ==========================================
    // 2. 关卡流程控制
    // ==========================================
    function startLevel() {
        const idx = gameState.currentLevelIndex;
        const total = CONFIG.levelImages.length;

        const badge = document.getElementById('level-badge');
        badge.innerText = `LEVEL ${idx + 1} / ${total}`;

        if (idx >= total) {
            handleFinalVictory();
            return;
        }

        const imgSrc = CONFIG.levelImages[idx];
        showLoading(`LOADING DATA: ${imgSrc}...`);

        const resolveImagePath = (src) => {
            if (src.startsWith('http://') || src.startsWith('https://') || src.startsWith('data:')) {
                return src;
            }
            if (CONFIG.basePath) {
                return CONFIG.basePath + src;
            }
            return src;
        };

        const fullImgSrc = resolveImagePath(imgSrc);

        const imageObj = new Image();
        imageObj.onload = () => {
            hideLoading();
            initGame(imageObj);
        };
        imageObj.onerror = () => {
            console.error(`[Puzzle] Failed to load image: ${fullImgSrc}`);
            // 错误处理：尝试跳过或报错
            if (gameState.currentLevelIndex + 1 < CONFIG.levelImages.length) {
                showLoading(`ERROR: ${imgSrc} MISSING - SKIPPING...`);
                setTimeout(() => {
                    gameState.currentLevelIndex++;
                    startLevel();
                }, 2000);
            } else {
                showLoading(`ERROR: ${imgSrc} NOT FOUND`);
            }
        };
        if (fullImgSrc.startsWith('http')) {
            imageObj.crossOrigin = 'Anonymous';
        }
        imageObj.src = fullImgSrc;
    }

    function handleLevelComplete() {
        gameState.isGameActive = false;

        const isLastLevel = (gameState.currentLevelIndex + 1) >= CONFIG.levelImages.length;
        const textStr = isLastLevel ? '碎片已恢复' : '已完成所有碎片恢复';
        const color = isLastLevel ? '#d90018' : '#ffffff';

        playTextAnim(textStr, color, () => {
            if (isLastLevel) {
                setTimeout(() => {
                    console.log('[Puzzle] All levels done. Sending complete message...');
                    window.parent.postMessage({
                        type: 'minigame-complete',
                        result: { success: true }
                    }, '*');
                }, 1000);
            } else {
                gameState.currentLevelIndex++;
                setTimeout(() => {
                    startLevel();
                }, 1000);
            }
        });
    }

    function handleFinalVictory() {
        // 兜底逻辑，通常不会直接调这个
        window.parent.postMessage({ type: 'minigame-complete', result: { success: true } }, '*');
    }

    // ==========================================
    // 3. Konva 游戏逻辑
    // ==========================================
    function initGame(img) {
        gameState.isGameActive = true;
        gameState.completedCount = 0;

        const stageW = window.innerWidth - 40;
        const stageH = window.innerHeight - 40;

        if (stage) stage.destroy();

        stage = new Konva.Stage({
            container: 'game-box',
            width: stageW,
            height: stageH
        });
        layer = new Konva.Layer();
        stage.add(layer);

        // 计算缩放适应屏幕
        const targetW = stageW * 0.7;
        const targetH = stageH * 0.7;
        const scale = Math.min(targetW / img.width, targetH / img.height);

        const boardW = img.width * scale;
        const boardH = img.height * scale;
        const startX = (stageW - boardW) / 2;
        const startY = (stageH - boardH) / 2;

        const gridPoints = [];
        const tileW = boardW / CONFIG.cols;
        const tileH = boardH / CONFIG.rows;

        // 生成不规则网格点
        for (let r = 0; r <= CONFIG.rows; r++) {
            gridPoints[r] = [];
            for (let c = 0; c <= CONFIG.cols; c++) {
                let x = startX + c * tileW;
                let y = startY + r * tileH;
                if (r > 0 && r < CONFIG.rows && c > 0 && c < CONFIG.cols) {
                    x += (Math.random() - 0.5) * CONFIG.jitterAmount * 2;
                    y += (Math.random() - 0.5) * CONFIG.jitterAmount * 2;
                }
                gridPoints[r][c] = {x, y};
            }
        }

        // 底部提示图
        const hintImg = new Konva.Image({
            x: startX, y: startY, image: img,
            width: boardW, height: boardH, opacity: 0.1, listening: false
        });
        layer.add(hintImg);

        // 创建碎片
        for (let r = 0; r < CONFIG.rows; r++) {
            for (let c = 0; c < CONFIG.cols; c++) {
                createPiece(r, c, gridPoints, img, scale, startX, startY, tileW, tileH, stageW, stageH);
            }
        }
        layer.draw();
    }

    // ★★★ 核心修复逻辑：碎片创建与交互 ★★★
    function createPiece(r, c, gridPoints, img, scale, startX, startY, tileW, tileH, stageW, stageH) {
        const pTL = gridPoints[r][c];
        const pTR = gridPoints[r][c+1];
        const pBR = gridPoints[r+1][c+1];
        const pBL = gridPoints[r+1][c];

        const cx = (pTL.x + pTR.x + pBR.x + pBL.x) / 4;
        const cy = (pTL.y + pTR.y + pBR.y + pBL.y) / 4;

        const localPts = {
            tl: { x: pTL.x - cx, y: pTL.y - cy },
            tr: { x: pTR.x - cx, y: pTR.y - cy },
            br: { x: pBR.x - cx, y: pBR.y - cy },
            bl: { x: pBL.x - cx, y: pBL.y - cy }
        };

        const piece = new Konva.Shape({
            sceneFunc: function(ctx, shape) {
                ctx.beginPath();
                ctx.moveTo(localPts.tl.x, localPts.tl.y);
                ctx.lineTo(localPts.tr.x, localPts.tr.y);
                ctx.lineTo(localPts.br.x, localPts.br.y);
                ctx.lineTo(localPts.bl.x, localPts.bl.y);
                ctx.closePath();
                ctx.fillStrokeShape(shape);
            },
            x: cx, y: cy,
            fillPatternImage: img,
            fillPatternOffset: {
                x: (cx - startX) / scale,
                y: (cy - startY) / scale
            },
            fillPatternScale: { x: scale, y: scale },
            draggable: true,
            stroke: '#888', strokeWidth: 1,
            shadowColor: 'black', shadowBlur: 10, shadowOpacity: 0.3,
        });

        piece.targetX = cx;
        piece.targetY = cy;

        // 随机散落
        const randX = Math.random() * (stageW - tileW) + tileW/2;
        const randY = Math.random() * (stageH - tileH) + tileH/2;
        piece.position({x: randX, y: randY});
        piece.rotation(Math.floor(Math.random() * 4) * 90);

        // ==========================================
        //  修复后的交互变量
        // ==========================================
        let dragStartX = 0;
        let dragStartY = 0;
        let lastTapTime = 0;

        // 1. 旋转动画封装
        const rotateMe = (node) => {
            if (!node.draggable()) return;
            const currentRot = node.rotation();
            const snappedRot = Math.round(currentRot / 90) * 90;
            const newRot = snappedRot + 90;

            new Konva.Tween({
                node: node,
                duration: 0.2,
                rotation: newRot,
                easing: Konva.Easings.BackEaseOut,
                onFinish: () => checkSnap(node)
            }).play();
        };

        // 2. 双击检测逻辑 (共用)
        const handleDoubleTapCheck = () => {
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastTapTime;

            // 间隔小于 300ms 视为双击
            if (timeDiff < 300 && timeDiff > 0) {
                rotateMe(piece);
                lastTapTime = 0; // 防止三连击触发两次
            } else {
                lastTapTime = currentTime;
            }
        };

        // 事件绑定
        piece.on('mouseover', () => document.body.style.cursor = 'grab');
        piece.on('mouseout', () => document.body.style.cursor = 'default');

        // --- 拖拽开始：记录坐标 ---
        piece.on('dragstart', function() {
            this.moveToTop();
            this.shadowOpacity(0.6);
            document.body.style.cursor = 'grabbing';
            dragStartX = this.x();
            dragStartY = this.y();
        });

        // --- 场景A：完全静止的点击 (PC/iPad 极稳的手) ---
        piece.on('click tap', function(e) {
            // 阻止冒泡
            if (e && e.cancelBubble) e.cancelBubble = true;
            handleDoubleTapCheck();
        });

        // --- 场景B：微小抖动的点击 (被视为拖拽结束) ---
        piece.on('dragend', function() {
            this.shadowOpacity(0.3);
            document.body.style.cursor = 'grab';

            const dx = this.x() - dragStartX;
            const dy = this.y() - dragStartY;
            const dist = Math.sqrt(dx*dx + dy*dy);

            // 容差 7 像素
            if (dist < 7) {
                handleDoubleTapCheck();
            } else {
                // 真正的拖拽移动
                checkSnap(this);
            }
        });

        // --- 场景C：右键旋转 (PC 备用) ---
        piece.on('contextmenu', function(e) {
            e.evt.preventDefault();
            rotateMe(this);
        });

        layer.add(piece);
    }

    function checkSnap(node) {
        if (!gameState.isGameActive) return;

        const dx = node.x() - node.targetX;
        const dy = node.y() - node.targetY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        let rot = Math.round(node.rotation()) % 360;
        if (rot < 0) rot += 360;

        if (dist < CONFIG.snapDist && rot === 0) {
            node.position({x: node.targetX, y: node.targetY});
            node.rotation(0);
            node.draggable(false);
            node.moveToBottom();
            node.stroke(null);
            node.shadowOpacity(0);
            node.off('dragstart dragmove dragend click tap contextmenu mouseover mouseout');

            new Konva.Tween({ node: node, duration: 0.1, scaleX: 1, scaleY: 1 }).play();

            gameState.completedCount++;
            layer.draw();

            if (gameState.completedCount >= CONFIG.rows * CONFIG.cols) {
                handleLevelComplete();
            }
        }
    }

    // ==========================================
    // 4. 辅助视觉效果
    // ==========================================
    function showLoading(text) {
        const el = document.getElementById('loading-layer');
        el.innerHTML = text;
        el.style.display = 'block';
        document.getElementById('game-box').style.opacity = 0;
    }

    function hideLoading() {
        document.getElementById('loading-layer').style.display = 'none';
        document.getElementById('game-box').style.opacity = 1;
    }

    function playTextAnim(textStr, color, callback) {
        const text = new Konva.Text({
            x: stage.width() / 2, y: stage.height() / 2,
            text: textStr,
            fontSize: 60, fontFamily: 'Impact',
            fill: color, stroke: 'white', strokeWidth: 2,
            shadowColor: 'black', shadowOffset: {x: 5, y: 5},
            opacity: 0, rotation: -5
        });
        text.offsetX(text.width() / 2);
        text.offsetY(text.height() / 2);
        layer.add(text);

        new Konva.Tween({
            node: text, duration: 0.4,
            opacity: 1, scaleX: 1.2, scaleY: 1.2,
            easing: Konva.Easings.BackEaseOut,
            onFinish: () => {
                setTimeout(() => {
                    new Konva.Tween({
                        node: text, duration: 0.2, opacity: 0, scaleX: 2, scaleY: 2,
                        onFinish: () => {
                            text.destroy();
                            if(callback) callback();
                        }
                    }).play();
                }, 1500);
            }
        }).play();
    }
</script>
</body>
</html>